{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\nReuse allows us to implement React components and aplications in a \nfunctional and reactive\n way, making it much more natural to deal with the asynchronicity of interfaces, as well as isolating side effects away from the actual implementation.\n\n\nThink of all the data and events you're used to work with in React, such as props, state, lifecycle, user interaction, etc. These are all asynchronous by nature, the data change and the events emit along time, more than often triggered by previous events and producing new ones. Basicaly what Reuse does is to turn all of this data and events into reactive streams, completely embracing the asynchronicity and allowing us to take advantage of it.\n\n\nComponent's Structure\n\n\nA Reuse component is a function which receives a \nsources\n object and returns a \nsinks\n object.\n\n\nThe \nsources\n is how we access - as streams - all the data from the React side, such as props, state, lifecycle, etc.\n\n\nThe \nsinks\n is how we describe our component's behaviour and side effecs, in a declarative way. In other words, \nside effects are never executed imperatively inside a component implementation; they are instead described in the sinks, to be isolated executed on the Reuse side\n.\n\n\nconst\n \ncomponent\n \n=\n \n(\nsources\n)\n \n=\n \n{\n\n  \nconst\n \nsinks\n \n=\n \n{}\n\n  \nreturn\n \nsinks\n\n\n}\n\n\n\n\n\n\nHello World\n\n\nA simple component may return a \nsinks\n object containing only a \nview\n property, which is responsible for describing how the component should render.\n\n\nconst\n \nHelloWorld\n \n=\n \n(\nsources\n)\n \n=\n \n({\n\n  \nview\n:\n \n(\nviewArgs\n)\n \n=\n\n    \ndiv\n\n      \np\nHello\n \nWorld\n/p\n\n    \n/div\n\n\n})\n\n\n\n\n\n\nNow our component is implemented, we must use Reuse to convert it to a conventional React component:\n\n\nimport\n \nReactDOM\n \nfrom\n \nreact-dom\n\n\nimport\n \nreuse\n \nfrom\n \nreuse\n\n\n\nconst\n \nmain\n \n=\n \n(\nsources\n)\n \n=\n \n({\n\n  \nview\n:\n \n(\nviewArgs\n)\n \n=\n\n    \ndiv\n\n      \np\nHello\n \nWorld\n/p\n\n    \n/div\n\n\n})\n\n\n\nconst\n \nHelloWorld\n \n=\n \nreuse\n(\nmain\n)\n\n\n\nReactDOM\n.\nrender\n(\n\n  \nHelloWorld\n \n/\n,\n\n  \ndocument\n.\ngetElementById\n(\napp\n)\n\n\n)", 
            "title": "Introduction"
        }, 
        {
            "location": "/#introduction", 
            "text": "Reuse allows us to implement React components and aplications in a  functional and reactive  way, making it much more natural to deal with the asynchronicity of interfaces, as well as isolating side effects away from the actual implementation.  Think of all the data and events you're used to work with in React, such as props, state, lifecycle, user interaction, etc. These are all asynchronous by nature, the data change and the events emit along time, more than often triggered by previous events and producing new ones. Basicaly what Reuse does is to turn all of this data and events into reactive streams, completely embracing the asynchronicity and allowing us to take advantage of it.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#components-structure", 
            "text": "A Reuse component is a function which receives a  sources  object and returns a  sinks  object.  The  sources  is how we access - as streams - all the data from the React side, such as props, state, lifecycle, etc.  The  sinks  is how we describe our component's behaviour and side effecs, in a declarative way. In other words,  side effects are never executed imperatively inside a component implementation; they are instead described in the sinks, to be isolated executed on the Reuse side .  const   component   =   ( sources )   =   { \n   const   sinks   =   {} \n   return   sinks  }", 
            "title": "Component's Structure"
        }, 
        {
            "location": "/#hello-world", 
            "text": "A simple component may return a  sinks  object containing only a  view  property, which is responsible for describing how the component should render.  const   HelloWorld   =   ( sources )   =   ({ \n   view :   ( viewArgs )   = \n     div \n       p Hello   World /p \n     /div  })   Now our component is implemented, we must use Reuse to convert it to a conventional React component:  import   ReactDOM   from   react-dom  import   reuse   from   reuse  const   main   =   ( sources )   =   ({ \n   view :   ( viewArgs )   = \n     div \n       p Hello   World /p \n     /div  })  const   HelloWorld   =   reuse ( main )  ReactDOM . render ( \n   HelloWorld   / , \n   document . getElementById ( app )  )", 
            "title": "Hello World"
        }, 
        {
            "location": "/quick-start/props-and-state/", 
            "text": "Props and State\n\n\nProps and state are the two main sources of truth in a React component. In Reuse, streams of props and state are available through the \nsources\n object, what enables us to combine or compose them with other asynchronous data, such as lifecycle events or user interaction.\n\n\nHowever, as two particularly important sources of truth, they are also passed as plain objects to the \nview\n sink, so we can easely use them in the rendering.\n\n\nimport\n \nreuse\n \nfrom\n \nreuse\n\n\n\nconst\n \nComponent\n \n=\n \nreuse\n(\n\n  \n(\nsources\n)\n \n=\n \n{\n\n    \n// streams of props and state\n\n    \nconst\n \n{\n \nprops\n,\n \nstate\n \n}\n \n=\n \nsources\n\n\n    \nreturn\n \n{\n\n      \n// plain props and state objects\n\n      \n// (pay atention to the destructuring of the argument)\n\n      \nview\n:\n \n({\n \nprops\n,\n \nstate\n \n})\n \n=\n \n(\n\n        \ndiv\n\n          \np\n{\nprops\n.\nfoo\n}\np\n/\n\n          \np\n{\nstate\n.\nbar\n}\np\n/\n\n        \n/div\n\n      \n)\n\n    \n}\n\n  \n}\n\n\n)\n\n\n\n\n\n\nProps\n\n\nAs showed above, there are two ways of using a component's props in Reuse:\n\n\n\n\nthrough the argument of the \nview\n function, as a plain object for rendering purposes;\n\n\nthrough the \nsources.props\n stream, generaly used for composition of streams - as shown on the \nState\n topic bellow. \n\n\n\n\nAny changes on a component's props will cause the \nview\n sink function to be called again with the updated value, as well as trigger a new emission on the \nsources.props\n stream.\n\n\nState\n\n\nAs with props, the state of a component is assessible from the \nsources.state\n stream, as well as from the \nview\n sink argument.\n\n\nUnlike props, though, the state can be updated from inside the component who owns it. Since this is a side effect, it must be done through a sink. In this case, the \nstateReducer\n sink.\n\n\nA \ninitialState\n sink may also be used to set the initial state when needed.\n\n\nimport\n \nreuse\n \nfrom\n \nreuse\n\n\nimport\n \nxs\n \nfrom\n \nxstream\n\n\n\nconst\n \nIncrementer\n \n=\n \nreuse\n(\nsources\n \n=\n \n{\n\n  \nconst\n \nonIncrement\n \n=\n \nxs\n.\nStream\n.\ncreate\n()\n\n\n  \nreturn\n \n{\n\n    \ninitialState\n:\n \n{\n\n      \ncount\n: \n0\n,\n\n    \n},\n\n\n    \nstateReducer\n: \nincrement.mapTo\n(\n\n      \nstate\n \n=\n \n({\n\n        \ncount\n: \nstate.count\n \n+\n \n1\n,\n\n      \n})\n\n    \n),\n\n\n    \n// see more about the emitter in Handling Events section\n\n    \nview\n:\n \n({\n \nstate\n,\n \nemitter\n \n})\n \n=\n \n(\n\n      \np\nCount\n:\n \n{\nstate\n.\ncount\n}\n/p\n\n      \nbutton\n \nonClick\n=\n{\nemmiter\n.\nemit\n(\nonIncrement\n)}\n\n        \nIncrement\n\n      \n/button\n\n    \n)\n\n  \n}\n\n\n})\n\n\n\n\n\n\nThe \nstateReducer\n sink is a stream of state reducers: functions which receive the latest state as argument and return a new one.\n\n\nFor a more complex exemple, we may compose state and props streams to achieve a more generic incrementer, whose step size are specified via props:\n\n\nimport\n \nreuse\n \nfrom\n \nreuse\n\n\nimport\n \nsampleCombine\n \nfrom\n \nxstream/extra/sampleCombine\n\n\nimport\n \nxs\n \nfrom\n \nxstream\n\n\n\nconst\n \nIncrementer\n \n=\n \nreuse\n(\n\n  \n(\nsources\n)\n \n=\n \n{\n\n    \nconst\n \nonIncrement\n \n=\n \nxs\n.\nStream\n.\ncreate\n()\n\n\n    \nreturn\n \n{\n\n      \ninitialState\n:\n \n{\n\n        \ncount\n: \n0\n\n      \n}\n\n\n      \nstateReducer\n: \nonIncrement\n\n        \n.\ncompose\n(\nsampleCombine\n(\n\n          \nsources\n.\nprops\n\n            \n.\nmap\n(\nprops\n \n=\n \nprops\n.\nstep\n)\n\n        \n))\n\n        \n.\nmap\n(([\n_clickEvent\n,\n \nstep\n])\n \n=\n\n          \nstate\n \n=\n \n({\n\n            \ncount\n: \nstate.count\n \n+\n \nstep\n\n          \n})\n\n        \n)\n\n\n      \nview\n:\n \n({\n \nprops\n,\n \nstate\n,\n \nemitter\n \n})\n \n=\n \n(\n\n        \ndiv\n\n          \np\nCount\n:\n \n{\nstate\n.\ncount\n}\n/p\n\n          \nbutton\n \nonClick\n=\n{\nemitter\n.\nemit\n(\nonIncrement\n)}\n\n            \nIncrement\n \n{\nprops\n.\nstep\n}\n\n          \n/button\n\n        \n/div\n\n      \n)\n\n    \n}\n\n  \n}\n\n\n)\n\n\n\n\n\n\nNow we can render an incrementer which jump two units per click:\n\n\nIncrementer\n \nstep\n=\n{\n2\n}\n \n/", 
            "title": "Props and State"
        }, 
        {
            "location": "/quick-start/props-and-state/#props-and-state", 
            "text": "Props and state are the two main sources of truth in a React component. In Reuse, streams of props and state are available through the  sources  object, what enables us to combine or compose them with other asynchronous data, such as lifecycle events or user interaction.  However, as two particularly important sources of truth, they are also passed as plain objects to the  view  sink, so we can easely use them in the rendering.  import   reuse   from   reuse  const   Component   =   reuse ( \n   ( sources )   =   { \n     // streams of props and state \n     const   {   props ,   state   }   =   sources \n\n     return   { \n       // plain props and state objects \n       // (pay atention to the destructuring of the argument) \n       view :   ({   props ,   state   })   =   ( \n         div \n           p { props . foo } p / \n           p { state . bar } p / \n         /div \n       ) \n     } \n   }  )", 
            "title": "Props and State"
        }, 
        {
            "location": "/quick-start/props-and-state/#props", 
            "text": "As showed above, there are two ways of using a component's props in Reuse:   through the argument of the  view  function, as a plain object for rendering purposes;  through the  sources.props  stream, generaly used for composition of streams - as shown on the  State  topic bellow.    Any changes on a component's props will cause the  view  sink function to be called again with the updated value, as well as trigger a new emission on the  sources.props  stream.", 
            "title": "Props"
        }, 
        {
            "location": "/quick-start/props-and-state/#state", 
            "text": "As with props, the state of a component is assessible from the  sources.state  stream, as well as from the  view  sink argument.  Unlike props, though, the state can be updated from inside the component who owns it. Since this is a side effect, it must be done through a sink. In this case, the  stateReducer  sink.  A  initialState  sink may also be used to set the initial state when needed.  import   reuse   from   reuse  import   xs   from   xstream  const   Incrementer   =   reuse ( sources   =   { \n   const   onIncrement   =   xs . Stream . create () \n\n   return   { \n     initialState :   { \n       count :  0 , \n     }, \n\n     stateReducer :  increment.mapTo ( \n       state   =   ({ \n         count :  state.count   +   1 , \n       }) \n     ), \n\n     // see more about the emitter in Handling Events section \n     view :   ({   state ,   emitter   })   =   ( \n       p Count :   { state . count } /p \n       button   onClick = { emmiter . emit ( onIncrement )} \n         Increment \n       /button \n     ) \n   }  })   The  stateReducer  sink is a stream of state reducers: functions which receive the latest state as argument and return a new one.  For a more complex exemple, we may compose state and props streams to achieve a more generic incrementer, whose step size are specified via props:  import   reuse   from   reuse  import   sampleCombine   from   xstream/extra/sampleCombine  import   xs   from   xstream  const   Incrementer   =   reuse ( \n   ( sources )   =   { \n     const   onIncrement   =   xs . Stream . create () \n\n     return   { \n       initialState :   { \n         count :  0 \n       } \n\n       stateReducer :  onIncrement \n         . compose ( sampleCombine ( \n           sources . props \n             . map ( props   =   props . step ) \n         )) \n         . map (([ _clickEvent ,   step ])   = \n           state   =   ({ \n             count :  state.count   +   step \n           }) \n         ) \n\n       view :   ({   props ,   state ,   emitter   })   =   ( \n         div \n           p Count :   { state . count } /p \n           button   onClick = { emitter . emit ( onIncrement )} \n             Increment   { props . step } \n           /button \n         /div \n       ) \n     } \n   }  )   Now we can render an incrementer which jump two units per click:  Incrementer   step = { 2 }   /", 
            "title": "State"
        }, 
        {
            "location": "/quick-start/handling-events/", 
            "text": "Handling Events\n\n\nAs everything else, user interaction in Reuse is managed through streams. When an interface event occurs, instead of calling a function (the traditional React way), we emit the event to a stream.\n\n\nimport\n \nreuse\n \nfrom\n \nreuse\n\n\nimport\n \nxs\n \nfrom\n \nxstream\n\n\n\nconst\n \nApp\n \n=\n \nreuse\n(\n\n  \nsources\n \n=\n \n{\n\n    \nconst\n \nsomeAction\n \n=\n \nxs\n.\nStream\n.\ncreate\n()\n\n\n    \nreturn\n \n{\n\n      \nview\n:\n \n({\n \nemitter\n \n})\n \n=\n \n(\n\n        \nbutton\n \nonClick\n=\n{\nemitter\n(\nsomeAction\n).\nemit\n}\n\n          \nDo\n \nsome\n \naction\n\n        \n/button\n\n      \n)\n\n    \n}\n\n  \n}\n\n\n)\n\n\n\n\n\n\nNote the \nemitter\n constructor, extracted from the \nview\n argument. This helper allows us to easely forward an event's parameter directly to a stream, but not only that - it also lets us send arbitrary values or no value at all (a.k.a. \nundefined\n).\n\n\nThe \nemitter\n\n\nThe \nemitter\n constructor receives a stream and returns an object containing three methods: \nemit\n, \nsignal\n and \nemitValue\n. The three of them return functions that we can be passed to event props in JSX.\n\n\n\n\nemit\n will forward the event parameter to a specified stream;\n\n\nsignal\n will emit \nundefined\n to a specified stream, which is pretty helpful when the parameter doesn't metter;\n\n\nemitValue\n will emit an arbitrary value to the stream.\n\n\n\n\nimport\n \nreuse\n \nfrom\n \nreuse\n\n\nimport\n \nxs\n \nfrom\n \nxstream\n\n\n\nconst\n \nApp\n \n=\n \nreuse\n(\n\n    \nsources\n \n=\n \n{\n\n    \nconst\n \nfirstAction\n \n=\n \nxs\n.\nStream\n.\ncreate\nSyntheticEvent\n()\n\n    \nconst\n \nsecondAction\n \n=\n \nxs\n.\nStream\n.\ncreate\nundefined\n()\n\n    \nconst\n \nthirdAction\n \n=\n \nxs\n.\nStream\n.\ncreate\nnumber\n()\n\n\n    \nreturn\n \n{\n\n      \nview\n:\n \n({\n \nemitter\n \n})\n \n=\n \n(\n\n        \nbutton\n \nonClick\n=\n{\nemitter\n(\nfirstAction\n).\nemit\n}\nFirst\n \naction\n/button\n\n        \nbutton\n \nonClick\n=\n{\nemitter\n(\nsecondAction\n).\nsignal\n}\nSecond\n \naction\n/button\n\n        \nbutton\n \nonClick\n=\n{\nemitter\n(\nthirdAction\n).\nemitValue\n(\n2\n)}\nThird\n \naction\n/button\n\n      \n)\n\n    \n}\n\n  \n}\n\n\n)\n\n\n\n\n\n\nThe \nonClick\n prop of a button receives a function as argument. Once we click on the button, an object of type \nSyntheticEvent\n is passed to the function.\n\n\nIn the above exemple, if we click on the first button, the \nSynteticEvent\n will be emited by the \nfirstAction\n stream, as we're using \nemitter.emit\n.\n\n\nIf we click on the second button, though, the \nSynteticEvent\n will be discarted and \nsecondAction\n will emit \nundefined\n, as \nemitter.signal\n just \nsignals\n an event occurred.\n\n\nThen, if we click on the third button, the \nSynteticEvent\n will be discarted and \nthirdAction\n will emit the constant value \n2\n, as passed to \nemitter.emitValue\n.", 
            "title": "Handling Events"
        }, 
        {
            "location": "/quick-start/handling-events/#handling-events", 
            "text": "As everything else, user interaction in Reuse is managed through streams. When an interface event occurs, instead of calling a function (the traditional React way), we emit the event to a stream.  import   reuse   from   reuse  import   xs   from   xstream  const   App   =   reuse ( \n   sources   =   { \n     const   someAction   =   xs . Stream . create () \n\n     return   { \n       view :   ({   emitter   })   =   ( \n         button   onClick = { emitter ( someAction ). emit } \n           Do   some   action \n         /button \n       ) \n     } \n   }  )   Note the  emitter  constructor, extracted from the  view  argument. This helper allows us to easely forward an event's parameter directly to a stream, but not only that - it also lets us send arbitrary values or no value at all (a.k.a.  undefined ).", 
            "title": "Handling Events"
        }, 
        {
            "location": "/quick-start/handling-events/#the-emitter", 
            "text": "The  emitter  constructor receives a stream and returns an object containing three methods:  emit ,  signal  and  emitValue . The three of them return functions that we can be passed to event props in JSX.   emit  will forward the event parameter to a specified stream;  signal  will emit  undefined  to a specified stream, which is pretty helpful when the parameter doesn't metter;  emitValue  will emit an arbitrary value to the stream.   import   reuse   from   reuse  import   xs   from   xstream  const   App   =   reuse ( \n     sources   =   { \n     const   firstAction   =   xs . Stream . create SyntheticEvent () \n     const   secondAction   =   xs . Stream . create undefined () \n     const   thirdAction   =   xs . Stream . create number () \n\n     return   { \n       view :   ({   emitter   })   =   ( \n         button   onClick = { emitter ( firstAction ). emit } First   action /button \n         button   onClick = { emitter ( secondAction ). signal } Second   action /button \n         button   onClick = { emitter ( thirdAction ). emitValue ( 2 )} Third   action /button \n       ) \n     } \n   }  )   The  onClick  prop of a button receives a function as argument. Once we click on the button, an object of type  SyntheticEvent  is passed to the function.  In the above exemple, if we click on the first button, the  SynteticEvent  will be emited by the  firstAction  stream, as we're using  emitter.emit .  If we click on the second button, though, the  SynteticEvent  will be discarted and  secondAction  will emit  undefined , as  emitter.signal  just  signals  an event occurred.  Then, if we click on the third button, the  SynteticEvent  will be discarted and  thirdAction  will emit the constant value  2 , as passed to  emitter.emitValue .", 
            "title": "The emitter"
        }, 
        {
            "location": "/quick-start/lifecycle/", 
            "text": "Lifecycle\n\n\nLifecycle streams may be accessed through \nsources.lifecycle\n object, under the same names of React's lifecycle functions.\n\n\nimport\n \nreuse\n \nfrom\n \nreuse\n\n\n\nconst\n \nIncrementer\n \n=\n \nreuse\n(\n\n  \nsources\n \n=\n \n({\n\n    \ninitialState\n:\n \n{\n\n      \nisMounted\n: \nfalse\n,\n\n    \n},\n\n\n    \nstateReducer\n: \nsources.lifecycle\n\n      \n.\ncomponentDidMount\n\n      \n.\nmapTo\n(\nstate\n \n=\n \n({\n\n        \nisMounted\n: \ntrue\n,\n\n      \n})),\n\n  \n})\n\n\n)", 
            "title": "Lifecycle"
        }, 
        {
            "location": "/quick-start/lifecycle/#lifecycle", 
            "text": "Lifecycle streams may be accessed through  sources.lifecycle  object, under the same names of React's lifecycle functions.  import   reuse   from   reuse  const   Incrementer   =   reuse ( \n   sources   =   ({ \n     initialState :   { \n       isMounted :  false , \n     }, \n\n     stateReducer :  sources.lifecycle \n       . componentDidMount \n       . mapTo ( state   =   ({ \n         isMounted :  true , \n       })), \n   })  )", 
            "title": "Lifecycle"
        }, 
        {
            "location": "/quick-start/global-state/", 
            "text": "Global State\n\n\nReuse - unlike most frontend frameworks - has it's own way of managing application's global state, which is much similar to how we manage a component's local state: the global state is updated using the \nstoreReducer\n sink, and is available to the component through the \nsources.store\n stream.\n\n\nUnlike the local state, though, we must first create the store and make it available to the whole application through the React context.\n\n\nCreating a Store\n\n\nTo create a global store, use the helper function \ncreateStore\n.\n\n\nimport\n \n{\n \ncreateStore\n \n}\n \nfrom\n \nreuse\n\n\n\ninterface\n \nStore\n \n{\n\n  \nfoo\n: \nstring\n\n\n}\n\n\n\nconst\n \ninitialStore\n \n=\n \n{\n\n  \nfoo\n:\n \nbar\n\n\n}\n\n\n\nconst\n \nglobalStore\n \n=\n \ncreateStore\nStore\n(\ninitialStore\n)\n\n\n\n\n\n\nMaking the store available\n\n\nTo make the global store available, use the High Order Component \nwithStoreProvider\n.\n\n\nimport\n \nApp\n \nfrom\n \n./app\n\n\nimport\n \nstore\n \nfrom\n \n./store\n\n\n\nconst\n \nAppWithGlobalStore\n \n=\n \nwithStoreProvider\n(\nstore\n)(\nApp\n)\n\n\n\nReactDOM\n.\nrender\n(\nAppWithGlobalStore\n \n/\n,\n \ndocument\n.\ngetElementById\n(\napp\n))", 
            "title": "Global State"
        }, 
        {
            "location": "/quick-start/global-state/#global-state", 
            "text": "Reuse - unlike most frontend frameworks - has it's own way of managing application's global state, which is much similar to how we manage a component's local state: the global state is updated using the  storeReducer  sink, and is available to the component through the  sources.store  stream.  Unlike the local state, though, we must first create the store and make it available to the whole application through the React context.", 
            "title": "Global State"
        }, 
        {
            "location": "/quick-start/global-state/#creating-a-store", 
            "text": "To create a global store, use the helper function  createStore .  import   {   createStore   }   from   reuse  interface   Store   { \n   foo :  string  }  const   initialStore   =   { \n   foo :   bar  }  const   globalStore   =   createStore Store ( initialStore )", 
            "title": "Creating a Store"
        }, 
        {
            "location": "/quick-start/global-state/#making-the-store-available", 
            "text": "To make the global store available, use the High Order Component  withStoreProvider .  import   App   from   ./app  import   store   from   ./store  const   AppWithGlobalStore   =   withStoreProvider ( store )( App )  ReactDOM . render ( AppWithGlobalStore   / ,   document . getElementById ( app ))", 
            "title": "Making the store available"
        }
    ]
}