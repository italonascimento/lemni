{
    "docs": [
        {
            "location": "/", 
            "text": "Get Started\n\n\nHello World\n\n\nThe \nreuse\n function takes in a function which receives \nsources\n and return \nsinks\n (any similarity with Cycle.js is not just coincidence).\n\n\nimport\n \nreuse\n \nfrom\n \nreuse\n\n\nimport\n \nReactDOM\n \nfrom\n \nreact-dom\n\n\n\nconst\n \nApp\n \n=\n \nreuse\n(\nsources\n \n=\n \n{\n\n  \n// Component logic goes here\n\n\n  \nconst\n \nsinks\n \n=\n \n{\n\n    \nview\n:\n \n()\n \n=\n \n(\n\n      \ndiv\nHello\n \nWorld\n/div\n\n    \n)\n\n  \n}\n\n\n  \nreturn\n \nsinks\n\n\n})\n\n\n\n\n\n\nThe value returned by \nreuse\n is a common React component which can be used just like any other React component:\n\n\nReactDOM\n.\nrender\n(\nApp\n \n/\n,\n \ndocument\n.\ngetElementById\n(\napp\n))", 
            "title": "Get Started"
        }, 
        {
            "location": "/#get-started", 
            "text": "", 
            "title": "Get Started"
        }, 
        {
            "location": "/#hello-world", 
            "text": "The  reuse  function takes in a function which receives  sources  and return  sinks  (any similarity with Cycle.js is not just coincidence).  import   reuse   from   reuse  import   ReactDOM   from   react-dom  const   App   =   reuse ( sources   =   { \n   // Component logic goes here \n\n   const   sinks   =   { \n     view :   ()   =   ( \n       div Hello   World /div \n     ) \n   } \n\n   return   sinks  })   The value returned by  reuse  is a common React component which can be used just like any other React component:  ReactDOM . render ( App   / ,   document . getElementById ( app ))", 
            "title": "Hello World"
        }, 
        {
            "location": "/props/", 
            "text": "Props\n\n\nA stream of props is available through the sources object. The raw props are also passed to the \nview\n sink, so it can be easely used on the rendering.\n\n\nimport\n \nreuse\n \nfrom\n \nreuse\n\n\nimport\n \nReactDOM\n \nfrom\n \nreact-dom\n\n\n\ninterface\n \nProps\n \n{\n\n  \nname\n: \nstring\n\n\n}\n\n\n\nconst\n \nHello\n \n=\n \nreuse\nProps\n(\nsources\n \n=\n \n{\n\n  \nconst\n \nprops$\n \n=\n \nsources\n.\nprops\n\n\n  \nreturn\n \n{\n\n    \nview\n:\n \n({\n \nprops\n \n})\n \n=\n \n(\n\n      \ndiv\nHello\n \n{\nprops\n.\nname\n}\n/div\n\n    \n)\n\n  \n}\n\n\n})\n\n\n\nReactDOM\n.\nrender\n(\n\n  \nHello\n \nname\n=\nWorld\n \n/\n,\n\n  \ndocument\n.\ngetElementById\n(\napp\n)\n\n\n)", 
            "title": "Props"
        }, 
        {
            "location": "/props/#props", 
            "text": "A stream of props is available through the sources object. The raw props are also passed to the  view  sink, so it can be easely used on the rendering.  import   reuse   from   reuse  import   ReactDOM   from   react-dom  interface   Props   { \n   name :  string  }  const   Hello   =   reuse Props ( sources   =   { \n   const   props$   =   sources . props \n\n   return   { \n     view :   ({   props   })   =   ( \n       div Hello   { props . name } /div \n     ) \n   }  })  ReactDOM . render ( \n   Hello   name = World   / , \n   document . getElementById ( app )  )", 
            "title": "Props"
        }, 
        {
            "location": "/interaction/", 
            "text": "Interaction\n\n\nAll interaction in Reuse is managed through event streams. The events are defined inside the component function and emited inside the \nview\n sink. To easely emit events, use the \nemitter\n helper passed to \nview\n.\n\n\nconst\n \nApp\n \n=\n \nreuse\n(\nsources\n \n=\n \n{\n\n  \nconst\n \nsomeAction\n \n=\n \nStream\n.\ncreate\nSyntheticEvent\n()\n\n\n  \nreturn\n \n{\n\n    \nview\n:\n \n({\n \nemitter\n \n})\n \n=\n \n(\n\n      \nbutton\n \nonClick\n=\n{\nemmiter\n.\nemit\n(\nsomeAction\n)}\nDo\n \nsome\n \naction\n/button\n\n    \n)\n\n  \n}\n\n\n}\n\n\n\n\n\n\nThe \nemitter\n object has three methods: \nemit\n, \nsignal\n and \nemitValue\n:\n\n\n\n\nemit\n is used to create a lambda which emits to the stream de received argument;\n\n\nsignal\n is used to create a lambda which emits \nundefined\n to the stream. You may use it when the value doesn't metter;\n\n\nemitValue\n is used to create a lambda which emits a constant value to the stream.\n\n\n\n\nimport\n \nreuse\n \nfrom\n \nreuse\n\n\n\nconst\n \nApp\n \n=\n \nreuse\n(\nsources\n \n=\n \n{\n\n  \nconst\n \nfirstAction\n \n=\n \nStream\n.\ncreate\nSyntheticEvent\n()\n\n  \nconst\n \nsecondAction\n \n=\n \nStream\n.\ncreate\nundefined\n()\n\n  \nconst\n \nthirdAction\n \n=\n \nStream\n.\ncreate\nnumber\n()\n\n\n  \nreturn\n \n{\n\n    \nview\n:\n \n({\n \nemitter\n \n})\n \n=\n \n(\n\n      \nbutton\n \nonClick\n=\n{\nemmiter\n.\nemit\n(\nfirstAction\n)}\nFirst\n \naction\n/button\n\n      \nbutton\n \nonClick\n=\n{\nemmiter\n.\nsignal\n(\nsecondAction\n)}\nSecond\n \naction\n/button\n\n      \nbutton\n \nonClick\n=\n{\nemmiter\n.\nemitValue\n(\n2\n)(\nthirdAction\n)}\nThird\n \naction\n/button\n\n    \n)\n\n  \n}\n\n\n})", 
            "title": "Interaction"
        }, 
        {
            "location": "/interaction/#interaction", 
            "text": "All interaction in Reuse is managed through event streams. The events are defined inside the component function and emited inside the  view  sink. To easely emit events, use the  emitter  helper passed to  view .  const   App   =   reuse ( sources   =   { \n   const   someAction   =   Stream . create SyntheticEvent () \n\n   return   { \n     view :   ({   emitter   })   =   ( \n       button   onClick = { emmiter . emit ( someAction )} Do   some   action /button \n     ) \n   }  }   The  emitter  object has three methods:  emit ,  signal  and  emitValue :   emit  is used to create a lambda which emits to the stream de received argument;  signal  is used to create a lambda which emits  undefined  to the stream. You may use it when the value doesn't metter;  emitValue  is used to create a lambda which emits a constant value to the stream.   import   reuse   from   reuse  const   App   =   reuse ( sources   =   { \n   const   firstAction   =   Stream . create SyntheticEvent () \n   const   secondAction   =   Stream . create undefined () \n   const   thirdAction   =   Stream . create number () \n\n   return   { \n     view :   ({   emitter   })   =   ( \n       button   onClick = { emmiter . emit ( firstAction )} First   action /button \n       button   onClick = { emmiter . signal ( secondAction )} Second   action /button \n       button   onClick = { emmiter . emitValue ( 2 )( thirdAction )} Third   action /button \n     ) \n   }  })", 
            "title": "Interaction"
        }, 
        {
            "location": "/component-state/", 
            "text": "Component state\n\n\nThe state management is made through the \nstateReducer\n sink, which is a stream of reducer functions. Each reducer function must receive the latest state as argument and return a new one.\n\n\nA \ninitialState\n sink may be used to set the initial state when needed.\n\n\nThe raw state is passed to the \nview\n sink for use in the rendering.\n\n\nimport\n \nreuse\n \nfrom\n \nreuse\n\n\n\ninterface\n \nState\n \n{\n\n  \ncount\n: \nnumber\n\n\n}\n\n\n\nconst\n \nIncrementer\n \n=\n \nreuse\n{},\n \nState\n(\nsources\n \n=\n \n{\n\n  \nconst\n \nincrement\n \n=\n \nStream\n.\ncreate\nundefined\n()\n\n\n  \nreturn\n \n{\n\n    \ninitialState\n:\n \n{\n\n      \ncount\n: \n0\n,\n\n    \n},\n\n\n    \nstateReducer\n: \nincrement.mapTo\n((\nstate\n: \nState\n)\n \n=\n \n({\n\n      \ncount\n: \nstate.count\n \n+\n \n1\n,\n\n    \n})),\n\n\n    \nview\n:\n \n({\n \nstate\n,\n \nemitter\n \n})\n \n=\n \n(\n\n      \np\nCount\n:\n \n{\nstate\n.\ncount\n}\n/p\n\n      \nbutton\n \nonClick\n=\n{\nemmiter\n.\nsignal\n(\nincrement\n)}\nIncrement\n/button\n\n    \n)\n\n  \n}\n\n\n})", 
            "title": "Component State"
        }, 
        {
            "location": "/component-state/#component-state", 
            "text": "The state management is made through the  stateReducer  sink, which is a stream of reducer functions. Each reducer function must receive the latest state as argument and return a new one.  A  initialState  sink may be used to set the initial state when needed.  The raw state is passed to the  view  sink for use in the rendering.  import   reuse   from   reuse  interface   State   { \n   count :  number  }  const   Incrementer   =   reuse {},   State ( sources   =   { \n   const   increment   =   Stream . create undefined () \n\n   return   { \n     initialState :   { \n       count :  0 , \n     }, \n\n     stateReducer :  increment.mapTo (( state :  State )   =   ({ \n       count :  state.count   +   1 , \n     })), \n\n     view :   ({   state ,   emitter   })   =   ( \n       p Count :   { state . count } /p \n       button   onClick = { emmiter . signal ( increment )} Increment /button \n     ) \n   }  })", 
            "title": "Component state"
        }, 
        {
            "location": "/lifecycle/", 
            "text": "Lifecycle\n\n\nEvery React lifecycle event is emitted in the \nsources.lifecycle\n stream.\n\n\nimport\n \nreuse\n,\n \n{\n \nReactLifecycle\n \n}\n \nfrom\n \nreuse\n\n\n\ninterface\n \nState\n \n{\n\n  \nisMounted\n: \nboolean\n\n\n}\n\n\n\nconst\n \nIncrementer\n \n=\n \nreuse\n{},\n \nState\n(\nsources\n \n=\n \n({\n\n    \ninitialState\n:\n \n{\n\n      \nisMounted\n: \nfalse\n,\n\n    \n},\n\n\n    \nstateReducer\n: \nsources.lifecycle\n\n      \n.\nfilter\n(\nevent\n \n=\n \nevent\n \n===\n \nReactLifecycle\n.\ncomponentDidMount\n)\n\n      \n.\nmapTo\n((\nstate\n: \nState\n)\n \n=\n \n({\n\n        \nisMounted\n: \ntrue\n,\n\n      \n})),\n\n  \n})\n\n\n)", 
            "title": "Lifecycle"
        }, 
        {
            "location": "/lifecycle/#lifecycle", 
            "text": "Every React lifecycle event is emitted in the  sources.lifecycle  stream.  import   reuse ,   {   ReactLifecycle   }   from   reuse  interface   State   { \n   isMounted :  boolean  }  const   Incrementer   =   reuse {},   State ( sources   =   ({ \n     initialState :   { \n       isMounted :  false , \n     }, \n\n     stateReducer :  sources.lifecycle \n       . filter ( event   =   event   ===   ReactLifecycle . componentDidMount ) \n       . mapTo (( state :  State )   =   ({ \n         isMounted :  true , \n       })), \n   })  )", 
            "title": "Lifecycle"
        }
    ]
}