{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\nReuse allows us to implement React components and aplications in a functional/reactive way, making it much more natural to deal with the asynchronicity of interfaces.\n\n\nThink of all the data and events you're used to work with in React, such as props, state, lifecycle, user interaction, etc. These are all asynchronous by nature, the data change and the events emit along time, more than often triggered by previous events and producing new ones. Basicaly what Reuse does is to turn all of this data and events into reactive streams, completely embracing the asynchronicity and allowing us to take advantage of it.\n\n\nComponent's Structure\n\n\nA Reuse component is a function which receives a \nsources\n object and returns a \nsinks\n object. The \nsources\n is how we access the streams from the React side - props, state, lifecycle, etc. The \nsinks\n is how we describe our component behaviour.\n\n\nconst\n \ncomponent\n \n=\n \n(\nsources\n)\n \n=\n \n{\n\n  \nconst\n \nsinks\n \n=\n \n{}\n\n  \nreturn\n \nsinks\n\n\n}\n\n\n\n\n\n\nHello World\n\n\nA simple component may return a \nsinks\n object containing only a \nview\n property, which is responsible for describing how the component should render.\n\n\nconst\n \nHelloWorld\n \n=\n \n(\nsources\n)\n \n=\n \n({\n\n  \nview\n:\n \n(\nviewArgs\n)\n \n=\n\n    \ndiv\n\n      \np\nHello\n \nWorld\n/p\n\n    \n/div\n\n\n})\n\n\n\n\n\n\nNow our component is implemented, we must use Reuse to convert it to a conventional React component:\n\n\nimport\n \nReactDOM\n \nfrom\n \nreact-dom\n\n\nimport\n \nreuse\n \nfrom\n \nreuse\n\n\n\nconst\n \nmain\n \n=\n \n(\nsources\n)\n \n=\n \n({\n\n  \nview\n:\n \n(\nviewArgs\n)\n \n=\n\n    \ndiv\n\n      \np\nHello\n \nWorld\n/p\n\n    \n/div\n\n\n})\n\n\n\nconst\n \nHelloWorld\n \n=\n \nreuse\n(\nmain\n)\n\n\n\nReactDOM\n.\nrender\n(\n\n  \nHelloWorld\n \n/\n,\n\n  \ndocument\n.\ngetElementById\n(\napp\n)\n\n\n)", 
            "title": "Introduction"
        }, 
        {
            "location": "/#introduction", 
            "text": "Reuse allows us to implement React components and aplications in a functional/reactive way, making it much more natural to deal with the asynchronicity of interfaces.  Think of all the data and events you're used to work with in React, such as props, state, lifecycle, user interaction, etc. These are all asynchronous by nature, the data change and the events emit along time, more than often triggered by previous events and producing new ones. Basicaly what Reuse does is to turn all of this data and events into reactive streams, completely embracing the asynchronicity and allowing us to take advantage of it.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#components-structure", 
            "text": "A Reuse component is a function which receives a  sources  object and returns a  sinks  object. The  sources  is how we access the streams from the React side - props, state, lifecycle, etc. The  sinks  is how we describe our component behaviour.  const   component   =   ( sources )   =   { \n   const   sinks   =   {} \n   return   sinks  }", 
            "title": "Component's Structure"
        }, 
        {
            "location": "/#hello-world", 
            "text": "A simple component may return a  sinks  object containing only a  view  property, which is responsible for describing how the component should render.  const   HelloWorld   =   ( sources )   =   ({ \n   view :   ( viewArgs )   = \n     div \n       p Hello   World /p \n     /div  })   Now our component is implemented, we must use Reuse to convert it to a conventional React component:  import   ReactDOM   from   react-dom  import   reuse   from   reuse  const   main   =   ( sources )   =   ({ \n   view :   ( viewArgs )   = \n     div \n       p Hello   World /p \n     /div  })  const   HelloWorld   =   reuse ( main )  ReactDOM . render ( \n   HelloWorld   / , \n   document . getElementById ( app )  )", 
            "title": "Hello World"
        }, 
        {
            "location": "/quick-start/props-and-state/", 
            "text": "Props and State\n\n\nThe \nprops\n and \nstate\n objects are the two main sources of truth in a React component. In Reuse, streams of props and state are available through the \nsources\n object, what enables us to combine or compose them with other asynchronous data, such as lifecycle events or user interaction.\n\n\nHowever, as two particularly important sources of truth, they are also passed as plain objects to the \nview\n sink, so we can easely use them in the rendering.\n\n\nconst\n \nComponent\n \n=\n \nreuse\n(\n\n  \n(\nsources\n)\n \n=\n \n{\n\n    \nconst\n \nprops$\n \n=\n \nsources\n.\nprops\n\n    \nconst\n \nstate$\n \n=\n \nsources\n.\nstate\n\n\n    \nreturn\n \n{\n\n      \n// pay atention to the destructuring of the argument\n\n      \nview\n:\n \n({\n \nprops\n,\n \nstate\n \n})\n \n=\n \n(\n\n        \ndiv\n\n          \np\n{\nprops\n.\nfoo\n}\np\n/\n\n          \np\n{\nstate\n.\nbar\n}\np\n/\n\n        \n/div\n\n      \n)\n\n    \n}\n\n  \n}\n\n\n)\n\n\n\n\n\n\nProps\n\n\nThere are two ways of using a component's props:\n\n\n\n\nthrough the argument of the \nview\n function, for rendering prposes;\n\n\nthrough the \nsources.props\n stream, generaly used for composition of streams - as shown on the \nState\n topic bellow. \n\n\n\n\nThe stream of props is available at \nsources.props\n. Any changes on the props passed to the component will trigger a new emission on the stream, and will also cause a new call to the \nview\n sink with the updated props.\n\n\nAny changes on a component's props will cause the \nview\n sink function to be called again with the updated value, as well as trigger a new emission on the \nsources.props\n stream.\n\n\nState\n\n\nThe state management is made through the \nstateReducer\n sink, which is a stream of reducer functions. Each reducer function must receive the latest state as argument and return a new one.\n\n\nA \ninitialState\n sink may be used to set the initial state when needed.\n\n\nThe raw state is passed to the \nview\n sink for use in the rendering.\n\n\nimport\n \nreuse\n \nfrom\n \nreuse\n\n\n\ninterface\n \nState\n \n{\n\n  \ncount\n: \nnumber\n\n\n}\n\n\n\nconst\n \nIncrementer\n \n=\n \nreuse\n{},\n \nState\n(\nsources\n \n=\n \n{\n\n  \nconst\n \nincrement\n \n=\n \nStream\n.\ncreate\nundefined\n()\n\n\n  \nreturn\n \n{\n\n    \ninitialState\n:\n \n{\n\n      \ncount\n: \n0\n,\n\n    \n},\n\n\n    \nstateReducer\n: \nincrement.mapTo\n((\nstate\n: \nState\n)\n \n=\n \n({\n\n      \ncount\n: \nstate.count\n \n+\n \n1\n,\n\n    \n})),\n\n\n    \nview\n:\n \n({\n \nstate\n,\n \nemitter\n \n})\n \n=\n \n(\n\n      \np\nCount\n:\n \n{\nstate\n.\ncount\n}\n/p\n\n      \nbutton\n \nonClick\n=\n{\nemmiter\n.\nsignal\n(\nincrement\n)}\nIncrement\n/button\n\n    \n)\n\n  \n}\n\n\n})", 
            "title": "Props and State"
        }, 
        {
            "location": "/quick-start/props-and-state/#props-and-state", 
            "text": "The  props  and  state  objects are the two main sources of truth in a React component. In Reuse, streams of props and state are available through the  sources  object, what enables us to combine or compose them with other asynchronous data, such as lifecycle events or user interaction.  However, as two particularly important sources of truth, they are also passed as plain objects to the  view  sink, so we can easely use them in the rendering.  const   Component   =   reuse ( \n   ( sources )   =   { \n     const   props$   =   sources . props \n     const   state$   =   sources . state \n\n     return   { \n       // pay atention to the destructuring of the argument \n       view :   ({   props ,   state   })   =   ( \n         div \n           p { props . foo } p / \n           p { state . bar } p / \n         /div \n       ) \n     } \n   }  )", 
            "title": "Props and State"
        }, 
        {
            "location": "/quick-start/props-and-state/#props", 
            "text": "There are two ways of using a component's props:   through the argument of the  view  function, for rendering prposes;  through the  sources.props  stream, generaly used for composition of streams - as shown on the  State  topic bellow.    The stream of props is available at  sources.props . Any changes on the props passed to the component will trigger a new emission on the stream, and will also cause a new call to the  view  sink with the updated props.  Any changes on a component's props will cause the  view  sink function to be called again with the updated value, as well as trigger a new emission on the  sources.props  stream.", 
            "title": "Props"
        }, 
        {
            "location": "/quick-start/props-and-state/#state", 
            "text": "The state management is made through the  stateReducer  sink, which is a stream of reducer functions. Each reducer function must receive the latest state as argument and return a new one.  A  initialState  sink may be used to set the initial state when needed.  The raw state is passed to the  view  sink for use in the rendering.  import   reuse   from   reuse  interface   State   { \n   count :  number  }  const   Incrementer   =   reuse {},   State ( sources   =   { \n   const   increment   =   Stream . create undefined () \n\n   return   { \n     initialState :   { \n       count :  0 , \n     }, \n\n     stateReducer :  increment.mapTo (( state :  State )   =   ({ \n       count :  state.count   +   1 , \n     })), \n\n     view :   ({   state ,   emitter   })   =   ( \n       p Count :   { state . count } /p \n       button   onClick = { emmiter . signal ( increment )} Increment /button \n     ) \n   }  })", 
            "title": "State"
        }, 
        {
            "location": "/quick-start/handling-events/", 
            "text": "Handling Events\n\n\nAll interaction in Reuse is managed through event streams. The events are defined inside the component function and emited inside the \nview\n sink. To easely emit events, use the \nemitter\n helper passed to \nview\n.\n\n\nconst\n \nApp\n \n=\n \nreuse\n(\nsources\n \n=\n \n{\n\n  \nconst\n \nsomeAction\n \n=\n \nStream\n.\ncreate\nSyntheticEvent\n()\n\n\n  \nreturn\n \n{\n\n    \nview\n:\n \n({\n \nemitter\n \n})\n \n=\n \n(\n\n      \nbutton\n \nonClick\n=\n{\nemmiter\n.\nemit\n(\nsomeAction\n)}\nDo\n \nsome\n \naction\n/button\n\n    \n)\n\n  \n}\n\n\n}\n\n\n\n\n\n\nThe \nemitter\n object has three methods: \nemit\n, \nsignal\n and \nemitValue\n:\n\n\n\n\nemit\n is used to create a lambda which emits to the stream de received argument;\n\n\nsignal\n is used to create a lambda which emits \nundefined\n to the stream. You may use it when the value doesn't metter;\n\n\nemitValue\n is used to create a lambda which emits a constant value to the stream.\n\n\n\n\nimport\n \nreuse\n \nfrom\n \nreuse\n\n\n\nconst\n \nApp\n \n=\n \nreuse\n(\nsources\n \n=\n \n{\n\n  \nconst\n \nfirstAction\n \n=\n \nStream\n.\ncreate\nSyntheticEvent\n()\n\n  \nconst\n \nsecondAction\n \n=\n \nStream\n.\ncreate\nundefined\n()\n\n  \nconst\n \nthirdAction\n \n=\n \nStream\n.\ncreate\nnumber\n()\n\n\n  \nreturn\n \n{\n\n    \nview\n:\n \n({\n \nemitter\n \n})\n \n=\n \n(\n\n      \nbutton\n \nonClick\n=\n{\nemmiter\n.\nemit\n(\nfirstAction\n)}\nFirst\n \naction\n/button\n\n      \nbutton\n \nonClick\n=\n{\nemmiter\n.\nsignal\n(\nsecondAction\n)}\nSecond\n \naction\n/button\n\n      \nbutton\n \nonClick\n=\n{\nemmiter\n.\nemitValue\n(\n2\n)(\nthirdAction\n)}\nThird\n \naction\n/button\n\n    \n)\n\n  \n}\n\n\n})", 
            "title": "Handling Events"
        }, 
        {
            "location": "/quick-start/handling-events/#handling-events", 
            "text": "All interaction in Reuse is managed through event streams. The events are defined inside the component function and emited inside the  view  sink. To easely emit events, use the  emitter  helper passed to  view .  const   App   =   reuse ( sources   =   { \n   const   someAction   =   Stream . create SyntheticEvent () \n\n   return   { \n     view :   ({   emitter   })   =   ( \n       button   onClick = { emmiter . emit ( someAction )} Do   some   action /button \n     ) \n   }  }   The  emitter  object has three methods:  emit ,  signal  and  emitValue :   emit  is used to create a lambda which emits to the stream de received argument;  signal  is used to create a lambda which emits  undefined  to the stream. You may use it when the value doesn't metter;  emitValue  is used to create a lambda which emits a constant value to the stream.   import   reuse   from   reuse  const   App   =   reuse ( sources   =   { \n   const   firstAction   =   Stream . create SyntheticEvent () \n   const   secondAction   =   Stream . create undefined () \n   const   thirdAction   =   Stream . create number () \n\n   return   { \n     view :   ({   emitter   })   =   ( \n       button   onClick = { emmiter . emit ( firstAction )} First   action /button \n       button   onClick = { emmiter . signal ( secondAction )} Second   action /button \n       button   onClick = { emmiter . emitValue ( 2 )( thirdAction )} Third   action /button \n     ) \n   }  })", 
            "title": "Handling Events"
        }, 
        {
            "location": "/quick-start/lifecycle/", 
            "text": "Lifecycle\n\n\nEvery React lifecycle event is emitted in the \nsources.lifecycle\n stream.\n\n\nimport\n \nreuse\n,\n \n{\n \nReactLifecycle\n \n}\n \nfrom\n \nreuse\n\n\n\ninterface\n \nState\n \n{\n\n  \nisMounted\n: \nboolean\n\n\n}\n\n\n\nconst\n \nIncrementer\n \n=\n \nreuse\n{},\n \nState\n(\nsources\n \n=\n \n({\n\n    \ninitialState\n:\n \n{\n\n      \nisMounted\n: \nfalse\n,\n\n    \n},\n\n\n    \nstateReducer\n: \nsources.lifecycle\n\n      \n.\nfilter\n(\nevent\n \n=\n \nevent\n \n===\n \nReactLifecycle\n.\ncomponentDidMount\n)\n\n      \n.\nmapTo\n((\nstate\n: \nState\n)\n \n=\n \n({\n\n        \nisMounted\n: \ntrue\n,\n\n      \n})),\n\n  \n})\n\n\n)", 
            "title": "Lifecycle"
        }, 
        {
            "location": "/quick-start/lifecycle/#lifecycle", 
            "text": "Every React lifecycle event is emitted in the  sources.lifecycle  stream.  import   reuse ,   {   ReactLifecycle   }   from   reuse  interface   State   { \n   isMounted :  boolean  }  const   Incrementer   =   reuse {},   State ( sources   =   ({ \n     initialState :   { \n       isMounted :  false , \n     }, \n\n     stateReducer :  sources.lifecycle \n       . filter ( event   =   event   ===   ReactLifecycle . componentDidMount ) \n       . mapTo (( state :  State )   =   ({ \n         isMounted :  true , \n       })), \n   })  )", 
            "title": "Lifecycle"
        }, 
        {
            "location": "/quick-start/global-state/", 
            "text": "Global State\n\n\nReuse - unlike most frontend frameworks - has it's own way of managing application's global state, which is much similar to how we manage a component's local state: the global state is updated using the \nstoreReducer\n sink, and is available to the component through the \nsources.store\n stream.\n\n\nUnlike the local state, though, we must first create the store and make it available to the whole application through the React context.\n\n\nCreating a Store\n\n\nTo create a global store, use the helper function \ncreateStore\n.\n\n\nimport\n \n{\n \ncreateStore\n \n}\n \nfrom\n \nreuse\n\n\n\ninterface\n \nStore\n \n{\n\n  \nfoo\n: \nstring\n\n\n}\n\n\n\nconst\n \ninitialStore\n \n=\n \n{\n\n  \nfoo\n:\n \nbar\n\n\n}\n\n\n\nconst\n \nglobalStore\n \n=\n \ncreateStore\nStore\n(\ninitialStore\n)\n\n\n\n\n\n\nMaking the store available\n\n\nTo make the global store available, use the High Order Component \nwithStoreProvider\n.\n\n\nimport\n \nApp\n \nfrom\n \n./app\n\n\nimport\n \nstore\n \nfrom\n \n./store\n\n\n\nconst\n \nAppWithGlobalStore\n \n=\n \nwithStoreProvider\n(\nstore\n)(\nApp\n)\n\n\n\nReactDOM\n.\nrender\n(\nAppWithGlobalStore\n \n/\n,\n \ndocument\n.\ngetElementById\n(\napp\n))", 
            "title": "Global State"
        }, 
        {
            "location": "/quick-start/global-state/#global-state", 
            "text": "Reuse - unlike most frontend frameworks - has it's own way of managing application's global state, which is much similar to how we manage a component's local state: the global state is updated using the  storeReducer  sink, and is available to the component through the  sources.store  stream.  Unlike the local state, though, we must first create the store and make it available to the whole application through the React context.", 
            "title": "Global State"
        }, 
        {
            "location": "/quick-start/global-state/#creating-a-store", 
            "text": "To create a global store, use the helper function  createStore .  import   {   createStore   }   from   reuse  interface   Store   { \n   foo :  string  }  const   initialStore   =   { \n   foo :   bar  }  const   globalStore   =   createStore Store ( initialStore )", 
            "title": "Creating a Store"
        }, 
        {
            "location": "/quick-start/global-state/#making-the-store-available", 
            "text": "To make the global store available, use the High Order Component  withStoreProvider .  import   App   from   ./app  import   store   from   ./store  const   AppWithGlobalStore   =   withStoreProvider ( store )( App )  ReactDOM . render ( AppWithGlobalStore   / ,   document . getElementById ( app ))", 
            "title": "Making the store available"
        }
    ]
}