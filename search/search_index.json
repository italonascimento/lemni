{
    "docs": [
        {
            "location": "/", 
            "text": "What is Lemni?\n\n\nLemni allows us to implement React components and aplications in a \nfunctional and reactive\n way, making it much more natural to deal with the asynchronicity of interfaces, as well as isolating side effects away from the actual implementation.\n\n\nEmbracing Asynchronicity\n\n\nThink of all the data and events you're used to work with in React, such as props, state, lifecycle, user interaction, etc. These are all asynchronous by nature, the data change and the events emit along time, more than often triggered by previous events and producing new ones. Basicaly what Lemni does is to turn all of this data and events into reactive streams, completely embracing the asynchronicity and allowing us to take advantage of it.", 
            "title": "What is Lemni?"
        }, 
        {
            "location": "/#what-is-lemni", 
            "text": "Lemni allows us to implement React components and aplications in a  functional and reactive  way, making it much more natural to deal with the asynchronicity of interfaces, as well as isolating side effects away from the actual implementation.", 
            "title": "What is Lemni?"
        }, 
        {
            "location": "/#embracing-asynchronicity", 
            "text": "Think of all the data and events you're used to work with in React, such as props, state, lifecycle, user interaction, etc. These are all asynchronous by nature, the data change and the events emit along time, more than often triggered by previous events and producing new ones. Basicaly what Lemni does is to turn all of this data and events into reactive streams, completely embracing the asynchronicity and allowing us to take advantage of it.", 
            "title": "Embracing Asynchronicity"
        }, 
        {
            "location": "/quick-start/installation/", 
            "text": "Installation\n\n\nYou may install Lemni through npm or Yarn:\n\n\nnpm i @lemni/core\n\n\n# or\n\n\nyarn add @lemni/core", 
            "title": "Installation"
        }, 
        {
            "location": "/quick-start/installation/#installation", 
            "text": "You may install Lemni through npm or Yarn:  npm i @lemni/core # or \n\nyarn add @lemni/core", 
            "title": "Installation"
        }, 
        {
            "location": "/quick-start/components-structure/", 
            "text": "Component's Structure\n\n\nA Lemni component is a function which receives a \nsources\n object and returns a \nsinks\n object.\n\n\nThe \nsources\n is how we access - as streams - all the data from the React side, such as props, state, lifecycle, etc.\n\n\nThe \nsinks\n is how we describe our component's behaviour and side effecs, in a declarative way. In other words, \nside effects are never executed imperatively inside a component implementation; they are instead described in the sinks, to be isolated executed on the Lemni side\n.\n\n\nconst\n \ncomponent\n \n=\n \n(\nsources\n)\n \n=\n \n{\n\n  \nconst\n \nsinks\n \n=\n \n{}\n\n  \nreturn\n \nsinks\n\n\n}\n\n\n\n\n\n\nHello World\n\n\nA simple component may return a \nsinks\n object containing only a \nview\n property, which is responsible for describing how the component should render.\n\n\nimport\n \n{\n \nlemni\n \n}\n \nfrom\n \nlemni\n\n\n\nconst\n \nHelloWorld\n \n=\n \n(\nsources\n)\n \n=\n \n({\n\n  \nview\n:\n \n(\nviewArgs\n)\n \n=\n\n    \ndiv\n\n      \np\nHello\n \nWorld\n/p\n\n    \n/div\n\n\n})\n\n\n\n\n\n\nNow our component is implemented, we must use Lemni to convert it to a conventional React component:\n\n\nimport\n \n*\n \nas\n \nReact\n \nfrom\n \nreact\n\n\nimport\n \n*\n \nas\n \nReactDOM\n \nfrom\n \nreact-dom\n\n\nimport\n \n{\n \nlemni\n \n}\n \nfrom\n \nlemni\n\n\n\nconst\n \nmain\n \n=\n \n(\nsources\n)\n \n=\n \n({\n\n  \nview\n:\n \n(\nviewArgs\n)\n \n=\n\n    \ndiv\n\n      \np\nHello\n \nWorld\n/p\n\n    \n/div\n\n\n})\n\n\n\nconst\n \nHelloWorld\n \n=\n \nlemni\n(\nmain\n)\n\n\n\nReactDOM\n.\nrender\n(\n\n  \nHelloWorld\n \n/\n,\n\n  \ndocument\n.\ngetElementById\n(\napp\n)\n\n\n)", 
            "title": "Component's Structure"
        }, 
        {
            "location": "/quick-start/components-structure/#components-structure", 
            "text": "A Lemni component is a function which receives a  sources  object and returns a  sinks  object.  The  sources  is how we access - as streams - all the data from the React side, such as props, state, lifecycle, etc.  The  sinks  is how we describe our component's behaviour and side effecs, in a declarative way. In other words,  side effects are never executed imperatively inside a component implementation; they are instead described in the sinks, to be isolated executed on the Lemni side .  const   component   =   ( sources )   =   { \n   const   sinks   =   {} \n   return   sinks  }", 
            "title": "Component's Structure"
        }, 
        {
            "location": "/quick-start/components-structure/#hello-world", 
            "text": "A simple component may return a  sinks  object containing only a  view  property, which is responsible for describing how the component should render.  import   {   lemni   }   from   lemni  const   HelloWorld   =   ( sources )   =   ({ \n   view :   ( viewArgs )   = \n     div \n       p Hello   World /p \n     /div  })   Now our component is implemented, we must use Lemni to convert it to a conventional React component:  import   *   as   React   from   react  import   *   as   ReactDOM   from   react-dom  import   {   lemni   }   from   lemni  const   main   =   ( sources )   =   ({ \n   view :   ( viewArgs )   = \n     div \n       p Hello   World /p \n     /div  })  const   HelloWorld   =   lemni ( main )  ReactDOM . render ( \n   HelloWorld   / , \n   document . getElementById ( app )  )", 
            "title": "Hello World"
        }, 
        {
            "location": "/quick-start/props-and-state/", 
            "text": "Props and State\n\n\nProps and state are the two main sources of truth in a React component. In Lemni, streams of props and state are available through the \nsources\n object, what enables us to combine or compose them with other asynchronous data, such as lifecycle events or user interaction.\n\n\nHowever, as two particularly important sources of truth, they are also passed as plain objects to the \nview\n sink, so we can easely use them in the rendering.\n\n\nimport\n \n{\n \nlemni\n \n}\n \nfrom\n \nlemni\n\n\n\nconst\n \nComponent\n \n=\n \nlemni\n(\n\n  \n(\nsources\n)\n \n=\n \n{\n\n    \n// streams of props and state\n\n    \nconst\n \n{\n \nprops\n,\n \nstate\n \n}\n \n=\n \nsources\n\n\n    \nreturn\n \n{\n\n      \n// plain props and state objects\n\n      \n// (pay atention to the destructuring of the argument)\n\n      \nview\n:\n \n({\n \nprops\n,\n \nstate\n \n})\n \n=\n \n(\n\n        \ndiv\n\n          \np\n{\nprops\n.\nfoo\n}\np\n/\n\n          \np\n{\nstate\n.\nbar\n}\np\n/\n\n        \n/div\n\n      \n)\n\n    \n}\n\n  \n}\n\n\n)\n\n\n\n\n\n\nProps\n\n\nAs showed above, there are two ways of using a component's props in Lemni:\n\n\n\n\nthrough the argument of the \nview\n function, as a plain object for rendering purposes;\n\n\nthrough the \nsources.props\n stream, generaly used for composition of streams - as shown on the \nState\n topic bellow. \n\n\n\n\nAny changes on a component's props will cause the \nview\n sink function to be called again with the updated value, as well as trigger a new emission on the \nsources.props\n stream.\n\n\nState\n\n\nAs with props, the state of a component is assessible from the \nsources.state\n stream, as well as from the \nview\n sink argument.\n\n\nUnlike props, though, the state can be updated from inside the component who owns it. Since this is a side effect, it must be done through a sink. In this case, the \nstateReducer\n sink.\n\n\nA \ninitialState\n sink may also be used to set the initial state when needed.\n\n\nimport\n \n{\n \nlemni\n \n}\n \nfrom\n \nlemni\n\n\nimport\n \nxs\n \nfrom\n \nxstream\n\n\n\nconst\n \nIncrementer\n \n=\n \nlemni\n(\nsources\n \n=\n \n{\n\n  \nconst\n \nonIncrement\n \n=\n \nxs\n.\nStream\n.\ncreate\n()\n\n\n  \nreturn\n \n{\n\n    \ninitialState\n:\n \n{\n\n      \ncount\n: \n0\n,\n\n    \n},\n\n\n    \nstateReducer\n: \nonIncrement.mapTo\n(\n\n      \nstate\n \n=\n \n({\n\n        \ncount\n: \nstate.count\n \n+\n \n1\n,\n\n      \n})\n\n    \n),\n\n\n    \n// see more about the emitter in Handling Events section\n\n    \nview\n:\n \n({\n \nstate\n,\n \nemitter\n \n})\n \n=\n \n(\n\n      \np\nCount\n:\n \n{\nstate\n.\ncount\n}\n/p\n\n      \nbutton\n \nonClick\n=\n{\nemmiter\n(\nonIncrement\n).\nemit\n}\n\n        \nIncrement\n\n      \n/button\n\n    \n)\n\n  \n}\n\n\n})\n\n\n\n\n\n\nThe \nstateReducer\n sink is a stream of state reducers: functions which receive the latest state as argument and return a new one.\n\n\nFor a more complex example, we may compose state and props streams to achieve a more generic incrementer, whose step size are specified via props:\n\n\nimport\n \n{\n \nlemni\n \n}\n \nfrom\n \nlemni\n\n\nimport\n \nsampleCombine\n \nfrom\n \nxstream/extra/sampleCombine\n\n\nimport\n \nxs\n \nfrom\n \nxstream\n\n\n\nconst\n \nIncrementer\n \n=\n \nlemni\n(\n\n  \n(\nsources\n)\n \n=\n \n{\n\n    \nconst\n \nonIncrement\n \n=\n \nxs\n.\nStream\n.\ncreate\n()\n\n\n    \nreturn\n \n{\n\n      \ninitialState\n:\n \n{\n\n        \ncount\n: \n0\n\n      \n}\n\n\n      \nstateReducer\n: \nonIncrement\n\n        \n.\ncompose\n(\nsampleCombine\n(\n\n          \nsources\n.\nprops\n\n            \n.\nmap\n(\nprops\n \n=\n \nprops\n.\nstep\n)\n\n        \n))\n\n        \n.\nmap\n(([\n_clickEvent\n,\n \nstep\n])\n \n=\n\n          \nstate\n \n=\n \n({\n\n            \ncount\n: \nstate.count\n \n+\n \nstep\n\n          \n})\n\n        \n)\n\n\n      \nview\n:\n \n({\n \nprops\n,\n \nstate\n,\n \nemitter\n \n})\n \n=\n \n(\n\n        \ndiv\n\n          \np\nCount\n:\n \n{\nstate\n.\ncount\n}\n/p\n\n          \nbutton\n \nonClick\n=\n{\nemitter\n.\nemit\n(\nonIncrement\n)}\n\n            \nIncrement\n \n{\nprops\n.\nstep\n}\n\n          \n/button\n\n        \n/div\n\n      \n)\n\n    \n}\n\n  \n}\n\n\n)\n\n\n\n\n\n\nNow we can render an incrementer which jump two units per click:\n\n\nIncrementer\n \nstep\n=\n{\n2\n}\n \n/", 
            "title": "Props and State"
        }, 
        {
            "location": "/quick-start/props-and-state/#props-and-state", 
            "text": "Props and state are the two main sources of truth in a React component. In Lemni, streams of props and state are available through the  sources  object, what enables us to combine or compose them with other asynchronous data, such as lifecycle events or user interaction.  However, as two particularly important sources of truth, they are also passed as plain objects to the  view  sink, so we can easely use them in the rendering.  import   {   lemni   }   from   lemni  const   Component   =   lemni ( \n   ( sources )   =   { \n     // streams of props and state \n     const   {   props ,   state   }   =   sources \n\n     return   { \n       // plain props and state objects \n       // (pay atention to the destructuring of the argument) \n       view :   ({   props ,   state   })   =   ( \n         div \n           p { props . foo } p / \n           p { state . bar } p / \n         /div \n       ) \n     } \n   }  )", 
            "title": "Props and State"
        }, 
        {
            "location": "/quick-start/props-and-state/#props", 
            "text": "As showed above, there are two ways of using a component's props in Lemni:   through the argument of the  view  function, as a plain object for rendering purposes;  through the  sources.props  stream, generaly used for composition of streams - as shown on the  State  topic bellow.    Any changes on a component's props will cause the  view  sink function to be called again with the updated value, as well as trigger a new emission on the  sources.props  stream.", 
            "title": "Props"
        }, 
        {
            "location": "/quick-start/props-and-state/#state", 
            "text": "As with props, the state of a component is assessible from the  sources.state  stream, as well as from the  view  sink argument.  Unlike props, though, the state can be updated from inside the component who owns it. Since this is a side effect, it must be done through a sink. In this case, the  stateReducer  sink.  A  initialState  sink may also be used to set the initial state when needed.  import   {   lemni   }   from   lemni  import   xs   from   xstream  const   Incrementer   =   lemni ( sources   =   { \n   const   onIncrement   =   xs . Stream . create () \n\n   return   { \n     initialState :   { \n       count :  0 , \n     }, \n\n     stateReducer :  onIncrement.mapTo ( \n       state   =   ({ \n         count :  state.count   +   1 , \n       }) \n     ), \n\n     // see more about the emitter in Handling Events section \n     view :   ({   state ,   emitter   })   =   ( \n       p Count :   { state . count } /p \n       button   onClick = { emmiter ( onIncrement ). emit } \n         Increment \n       /button \n     ) \n   }  })   The  stateReducer  sink is a stream of state reducers: functions which receive the latest state as argument and return a new one.  For a more complex example, we may compose state and props streams to achieve a more generic incrementer, whose step size are specified via props:  import   {   lemni   }   from   lemni  import   sampleCombine   from   xstream/extra/sampleCombine  import   xs   from   xstream  const   Incrementer   =   lemni ( \n   ( sources )   =   { \n     const   onIncrement   =   xs . Stream . create () \n\n     return   { \n       initialState :   { \n         count :  0 \n       } \n\n       stateReducer :  onIncrement \n         . compose ( sampleCombine ( \n           sources . props \n             . map ( props   =   props . step ) \n         )) \n         . map (([ _clickEvent ,   step ])   = \n           state   =   ({ \n             count :  state.count   +   step \n           }) \n         ) \n\n       view :   ({   props ,   state ,   emitter   })   =   ( \n         div \n           p Count :   { state . count } /p \n           button   onClick = { emitter . emit ( onIncrement )} \n             Increment   { props . step } \n           /button \n         /div \n       ) \n     } \n   }  )   Now we can render an incrementer which jump two units per click:  Incrementer   step = { 2 }   /", 
            "title": "State"
        }, 
        {
            "location": "/quick-start/handling-events/", 
            "text": "Handling Events\n\n\nAs everything else, user interaction in Lemni is managed through streams. When an interface event occurs, instead of calling a function (the traditional React way), we emit the event to a stream.\n\n\nimport\n \n{\n \nlemni\n \n}\n \nfrom\n \nlemni\n\n\nimport\n \nxs\n \nfrom\n \nxstream\n\n\n\nconst\n \nApp\n \n=\n \nlemni\n(\n\n  \nsources\n \n=\n \n{\n\n    \nconst\n \nsomeAction\n \n=\n \nxs\n.\nStream\n.\ncreate\n()\n\n\n    \nreturn\n \n{\n\n      \nview\n:\n \n({\n \nemitter\n \n})\n \n=\n \n(\n\n        \nbutton\n \nonClick\n=\n{\nemitter\n(\nsomeAction\n).\nemit\n}\n\n          \nDo\n \nsome\n \naction\n\n        \n/button\n\n      \n)\n\n    \n}\n\n  \n}\n\n\n)\n\n\n\n\n\n\nNote the \nemitter\n constructor, extracted from the \nview\n argument. This helper allows us to easely forward an event's parameter directly to a stream, but not only that - it also lets us send arbitrary values or no value at all (a.k.a. \nundefined\n).\n\n\nThe \nemitter\n\n\nThe \nemitter\n constructor receives a stream and returns an object containing three methods: \nemit\n, \nsignal\n and \nemitValue\n. The three of them return functions that we can be passed to event props in JSX.\n\n\n\n\nemit\n will forward the event parameter to a specified stream;\n\n\nsignal\n will emit \nundefined\n to a specified stream, which is pretty helpful when the parameter doesn't matter;\n\n\nemitValue\n will emit an arbitrary value to the stream.\n\n\n\n\nimport\n \n{\n \nlemni\n \n}\n \nfrom\n \nlemni\n\n\nimport\n \nxs\n \nfrom\n \nxstream\n\n\n\nconst\n \nApp\n \n=\n \nlemni\n(\n\n    \nsources\n \n=\n \n{\n\n    \nconst\n \nfirstAction\n \n=\n \nxs\n.\nStream\n.\ncreate\nSyntheticEvent\n()\n\n    \nconst\n \nsecondAction\n \n=\n \nxs\n.\nStream\n.\ncreate\nundefined\n()\n\n    \nconst\n \nthirdAction\n \n=\n \nxs\n.\nStream\n.\ncreate\nnumber\n()\n\n\n    \nreturn\n \n{\n\n      \nview\n:\n \n({\n \nemitter\n \n})\n \n=\n \n(\n\n        \nbutton\n \nonClick\n=\n{\nemitter\n(\nfirstAction\n).\nemit\n}\nFirst\n \naction\n/button\n\n        \nbutton\n \nonClick\n=\n{\nemitter\n(\nsecondAction\n).\nsignal\n}\nSecond\n \naction\n/button\n\n        \nbutton\n \nonClick\n=\n{\nemitter\n(\nthirdAction\n).\nemitValue\n(\n2\n)}\nThird\n \naction\n/button\n\n      \n)\n\n    \n}\n\n  \n}\n\n\n)\n\n\n\n\n\n\nThe \nonClick\n prop of a button receives a function as argument. Once we click on the button, an object of type \nSyntheticEvent\n is passed to the function.\n\n\nIn the above example, if we click on the first button, the \nSynteticEvent\n will be emited by the \nfirstAction\n stream, as we're using \nemitter.emit\n.\n\n\nIf we click on the second button, though, the \nSynteticEvent\n will be discarted and \nsecondAction\n will emit \nundefined\n, as \nemitter.signal\n just \nsignals\n an event occurred.\n\n\nThen, if we click on the third button, the \nSynteticEvent\n will be discarted and \nthirdAction\n will emit the constant value \n2\n, as passed to \nemitter.emitValue\n.", 
            "title": "Handling Events"
        }, 
        {
            "location": "/quick-start/handling-events/#handling-events", 
            "text": "As everything else, user interaction in Lemni is managed through streams. When an interface event occurs, instead of calling a function (the traditional React way), we emit the event to a stream.  import   {   lemni   }   from   lemni  import   xs   from   xstream  const   App   =   lemni ( \n   sources   =   { \n     const   someAction   =   xs . Stream . create () \n\n     return   { \n       view :   ({   emitter   })   =   ( \n         button   onClick = { emitter ( someAction ). emit } \n           Do   some   action \n         /button \n       ) \n     } \n   }  )   Note the  emitter  constructor, extracted from the  view  argument. This helper allows us to easely forward an event's parameter directly to a stream, but not only that - it also lets us send arbitrary values or no value at all (a.k.a.  undefined ).", 
            "title": "Handling Events"
        }, 
        {
            "location": "/quick-start/handling-events/#the-emitter", 
            "text": "The  emitter  constructor receives a stream and returns an object containing three methods:  emit ,  signal  and  emitValue . The three of them return functions that we can be passed to event props in JSX.   emit  will forward the event parameter to a specified stream;  signal  will emit  undefined  to a specified stream, which is pretty helpful when the parameter doesn't matter;  emitValue  will emit an arbitrary value to the stream.   import   {   lemni   }   from   lemni  import   xs   from   xstream  const   App   =   lemni ( \n     sources   =   { \n     const   firstAction   =   xs . Stream . create SyntheticEvent () \n     const   secondAction   =   xs . Stream . create undefined () \n     const   thirdAction   =   xs . Stream . create number () \n\n     return   { \n       view :   ({   emitter   })   =   ( \n         button   onClick = { emitter ( firstAction ). emit } First   action /button \n         button   onClick = { emitter ( secondAction ). signal } Second   action /button \n         button   onClick = { emitter ( thirdAction ). emitValue ( 2 )} Third   action /button \n       ) \n     } \n   }  )   The  onClick  prop of a button receives a function as argument. Once we click on the button, an object of type  SyntheticEvent  is passed to the function.  In the above example, if we click on the first button, the  SynteticEvent  will be emited by the  firstAction  stream, as we're using  emitter.emit .  If we click on the second button, though, the  SynteticEvent  will be discarted and  secondAction  will emit  undefined , as  emitter.signal  just  signals  an event occurred.  Then, if we click on the third button, the  SynteticEvent  will be discarted and  thirdAction  will emit the constant value  2 , as passed to  emitter.emitValue .", 
            "title": "The emitter"
        }, 
        {
            "location": "/quick-start/lifecycle/", 
            "text": "Lifecycle\n\n\nLifecycle streams may be accessed through \nsources.lifecycle\n object, under the same names of React's lifecycle functions.\n\n\nimport\n \n{\n \nlemni\n \n}\n \nfrom\n \nlemni\n\n\n\nconst\n \nIncrementer\n \n=\n \nlemni\n(\n\n  \nsources\n \n=\n \n({\n\n    \ninitialState\n:\n \n{\n\n      \nisMounted\n: \nfalse\n,\n\n    \n},\n\n\n    \nstateReducer\n: \nsources.lifecycle\n\n      \n.\ncomponentDidMount\n\n      \n.\nmapTo\n(\nstate\n \n=\n \n({\n\n        \nisMounted\n: \ntrue\n,\n\n      \n})),\n\n  \n})\n\n\n)", 
            "title": "Lifecycle"
        }, 
        {
            "location": "/quick-start/lifecycle/#lifecycle", 
            "text": "Lifecycle streams may be accessed through  sources.lifecycle  object, under the same names of React's lifecycle functions.  import   {   lemni   }   from   lemni  const   Incrementer   =   lemni ( \n   sources   =   ({ \n     initialState :   { \n       isMounted :  false , \n     }, \n\n     stateReducer :  sources.lifecycle \n       . componentDidMount \n       . mapTo ( state   =   ({ \n         isMounted :  true , \n       })), \n   })  )", 
            "title": "Lifecycle"
        }, 
        {
            "location": "/quick-start/global-state/", 
            "text": "Global State (Store)\n\n\nLemni - unlike most frontend frameworks - has it's own way of managing an application's global state, which is in fact much similar to how it manages a component's local state.\n\n\nUnlike the local state, though, for the global state to work we must first create a central data repository - the \nstore\n - and make it available through the whole application by using React context.\n\n\nCreating The Store\n\n\nTo create the store, use the helper function \ncreateStore\n.\n\n\nimport\n \n{\n \ncreateStore\n \n}\n \nfrom\n \nlemni\n\n\n\nconst\n \ninitialStore\n \n=\n \n{\n\n  \nfoo\n:\n \nbar\n,\n\n\n}\n\n\n\nconst\n \nglobalStore\n \n=\n \ncreateStore\n(\ninitialStore\n)\n\n\n\n\n\n\nNow, to make it available through the whole app, use the High Order Component \nwithStoreProvider\n.\n\n\nimport\n \nApp\n \nfrom\n \n./app\n\n\nimport\n \nstore\n \nfrom\n \n./store\n\n\nimport\n \n{\n \nwithStoreProvider\n \n}\n \nfrom\n \nlemni\n\n\n\nconst\n \nAppWithGlobalStore\n \n=\n \nwithStoreProvider\n(\nstore\n)(\nApp\n)\n\n\n\nReactDOM\n.\nrender\n(\nAppWithGlobalStore\n \n/\n,\n \ndocument\n.\ngetElementById\n(\napp\n))\n\n\n\n\n\n\nUpdating And Consuming The Store\n\n\nAs mentioned above, global state in Lemni is managed almost in the same way as a component's local state, with only a slightly different terminology: it is updated using the \nstoreReducer\n sink, and is available through the \nsources.store\n stream.\n\n\nIt's important to notice, though, that unlike the local state, the store is not available inside the \nview\n sink function. This means that instead of directly accessing the global app's state inside our rendering function, we must first copy to the local state the pieces of data of our interest.\n\n\nimport\n \n{\n \nlemni\n \n}\n \nfrom\n \nlemni\n\n\nimport\n \nxs\n \nfrom\n \nxstream\n\n\n\nconst\n \nGlobalIncrementer\n \n=\n \nlemni\n(\nsources\n \n=\n \n{\n\n  \nconst\n \nonIncrement\n \n=\n \nxs\n.\nStream\n.\ncreate\n()\n\n\n  \nreturn\n \n{\n\n    \ninitialState\n:\n \n{\n\n      \ncount\n: \n0\n,\n\n    \n},\n\n\n    \n// copy store.count to local state\n\n    \nstateReducer\n: \nsources.store\n\n      \n.\nmap\n(\nstore\n \n=\n \nstore\n.\ncount\n)\n\n      \n.\nmap\n(\ncount\n \n=\n \n({\n\n        \ncount\n,\n\n      \n}))\n\n    \n,\n\n\n    \n// update store on click\n\n    \nstoreReducer\n: \nonIncrement.mapTo\n(\n\n      \nstore\n \n=\n \n({\n\n        \ncount\n: \nstore.count\n \n+\n \n1\n,\n\n      \n})\n\n    \n),\n\n\n    \nview\n:\n \n({\n \nstate\n,\n \nemitter\n \n})\n \n=\n \n(\n\n      \np\nCount\n:\n \n{\nstate\n.\ncount\n}\n/p\n\n      \nbutton\n \nonClick\n=\n{\nemmiter\n(\nonIncrement\n).\nsignal\n}\n\n        \nIncrement\n\n      \n/button\n\n    \n)\n\n  \n}\n\n\n})", 
            "title": "Global State (Store)"
        }, 
        {
            "location": "/quick-start/global-state/#global-state-store", 
            "text": "Lemni - unlike most frontend frameworks - has it's own way of managing an application's global state, which is in fact much similar to how it manages a component's local state.  Unlike the local state, though, for the global state to work we must first create a central data repository - the  store  - and make it available through the whole application by using React context.", 
            "title": "Global State (Store)"
        }, 
        {
            "location": "/quick-start/global-state/#creating-the-store", 
            "text": "To create the store, use the helper function  createStore .  import   {   createStore   }   from   lemni  const   initialStore   =   { \n   foo :   bar ,  }  const   globalStore   =   createStore ( initialStore )   Now, to make it available through the whole app, use the High Order Component  withStoreProvider .  import   App   from   ./app  import   store   from   ./store  import   {   withStoreProvider   }   from   lemni  const   AppWithGlobalStore   =   withStoreProvider ( store )( App )  ReactDOM . render ( AppWithGlobalStore   / ,   document . getElementById ( app ))", 
            "title": "Creating The Store"
        }, 
        {
            "location": "/quick-start/global-state/#updating-and-consuming-the-store", 
            "text": "As mentioned above, global state in Lemni is managed almost in the same way as a component's local state, with only a slightly different terminology: it is updated using the  storeReducer  sink, and is available through the  sources.store  stream.  It's important to notice, though, that unlike the local state, the store is not available inside the  view  sink function. This means that instead of directly accessing the global app's state inside our rendering function, we must first copy to the local state the pieces of data of our interest.  import   {   lemni   }   from   lemni  import   xs   from   xstream  const   GlobalIncrementer   =   lemni ( sources   =   { \n   const   onIncrement   =   xs . Stream . create () \n\n   return   { \n     initialState :   { \n       count :  0 , \n     }, \n\n     // copy store.count to local state \n     stateReducer :  sources.store \n       . map ( store   =   store . count ) \n       . map ( count   =   ({ \n         count , \n       })) \n     , \n\n     // update store on click \n     storeReducer :  onIncrement.mapTo ( \n       store   =   ({ \n         count :  store.count   +   1 , \n       }) \n     ), \n\n     view :   ({   state ,   emitter   })   =   ( \n       p Count :   { state . count } /p \n       button   onClick = { emmiter ( onIncrement ). signal } \n         Increment \n       /button \n     ) \n   }  })", 
            "title": "Updating And Consuming The Store"
        }, 
        {
            "location": "/quick-start/side-effects/", 
            "text": "Side Effects\n\n\nLemni provides us with a \nsideEffects\n sink, which is a default way to produce side effects from inside a component.\n\n\nTo produce a side effect, just emit an impure function through this sink and it will be executed on the Lemni side.\n\n\nimport\n \n{\n \nlemni\n \n}\n \nfrom\n \nlemni\n\n\nimport\n \nxs\n \nfrom\n \nxstream\n\n\n\nconst\n \nMyButton\n \n=\n \nlemni\n(\n\n  \nsources\n \n=\n \n(\n\n    \nconst\n \nonClick\n \n=\n \nxs\n.\nStream\n.\ncreate\n()\n\n\n    \nreturn\n \n{\n\n      \nsideEffects\n: \nonClick\n\n        \n// mapping to an impure function\n\n        \n.\nmapTo\n(()\n \n=\n \n{\n\n          \n// produce side effect\n\n          \nconsole\n.\nlog\n(\nClicked!\n)\n\n        \n}),\n\n\n      \nview\n:\n \n({\n \nemitter\n \n})\n \n=\n \n(\n\n        \nbutton\n \nonClick\n=\n{\nemitter\n(\nonClick\n).\nsignal\n}\n\n          \nClick\n \nMe\n\n        \n/button\n\n      \n)\n\n    \n}\n\n  \n)\n\n\n)", 
            "title": "Side Effects"
        }, 
        {
            "location": "/quick-start/side-effects/#side-effects", 
            "text": "Lemni provides us with a  sideEffects  sink, which is a default way to produce side effects from inside a component.  To produce a side effect, just emit an impure function through this sink and it will be executed on the Lemni side.  import   {   lemni   }   from   lemni  import   xs   from   xstream  const   MyButton   =   lemni ( \n   sources   =   ( \n     const   onClick   =   xs . Stream . create () \n\n     return   { \n       sideEffects :  onClick \n         // mapping to an impure function \n         . mapTo (()   =   { \n           // produce side effect \n           console . log ( Clicked! ) \n         }), \n\n       view :   ({   emitter   })   =   ( \n         button   onClick = { emitter ( onClick ). signal } \n           Click   Me \n         /button \n       ) \n     } \n   )  )", 
            "title": "Side Effects"
        }
    ]
}