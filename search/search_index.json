{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\nReuse allows us to implement React components and aplications in a functional/reactive way, making it much more natural to deal with the asynchronicity of interfaces.\n\n\nThink of all the data and events you're used to work with in React, such as props, state, lifecycle, user interaction, etc. These are all asynchronous by nature, the data change and the events emit along time, more than often triggered by previous events and producing new ones. Basicaly what Reuse does is to turn all of this data and events into reactive streams, completely embracing the asynchronicity and allowing us to take advantage of it.\n\n\nComponent's Structure\n\n\nA Reuse component is a function which receives a \nsources\n object and returns a \nsinks\n object. The \nsources\n is how we access the streams from the React side - props, state, lifecycle, etc. The \nsinks\n is how we describe our component behaviour.\n\n\nconst\n \ncomponent\n \n=\n \n(\nsources\n)\n \n=\n \n{\n\n  \nconst\n \nsinks\n \n=\n \n{}\n\n  \nreturn\n \nsinks\n\n\n}\n\n\n\n\n\n\nHello World\n\n\nA simple component may return a \nsinks\n object containing only a \nview\n property, which is responsible for describing how the component should render.\n\n\nconst\n \nHelloWorld\n \n=\n \n(\nsources\n)\n \n=\n \n({\n\n  \nview\n:\n \n(\nviewArgs\n)\n \n=\n\n    \ndiv\n\n      \np\nHello\n \nWorld\n/p\n\n    \n/div\n\n\n})\n\n\n\n\n\n\nNow our component is implemented, we must use Reuse to convert it to a conventional React component:\n\n\nimport\n \nReactDOM\n \nfrom\n \nreact-dom\n\n\nimport\n \nreuse\n \nfrom\n \nreuse\n\n\n\nconst\n \nmain\n \n=\n \n(\nsources\n)\n \n=\n \n({\n\n  \nview\n:\n \n(\nviewArgs\n)\n \n=\n\n    \ndiv\n\n      \np\nHello\n \nWorld\n/p\n\n    \n/div\n\n\n})\n\n\n\nconst\n \nHelloWorld\n \n=\n \nreuse\n(\nmain\n)\n\n\n\nReactDOM\n.\nrender\n(\n\n  \nHelloWorld\n \n/\n,\n\n  \ndocument\n.\ngetElementById\n(\napp\n)\n\n\n)", 
            "title": "Introduction"
        }, 
        {
            "location": "/#introduction", 
            "text": "Reuse allows us to implement React components and aplications in a functional/reactive way, making it much more natural to deal with the asynchronicity of interfaces.  Think of all the data and events you're used to work with in React, such as props, state, lifecycle, user interaction, etc. These are all asynchronous by nature, the data change and the events emit along time, more than often triggered by previous events and producing new ones. Basicaly what Reuse does is to turn all of this data and events into reactive streams, completely embracing the asynchronicity and allowing us to take advantage of it.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#components-structure", 
            "text": "A Reuse component is a function which receives a  sources  object and returns a  sinks  object. The  sources  is how we access the streams from the React side - props, state, lifecycle, etc. The  sinks  is how we describe our component behaviour.  const   component   =   ( sources )   =   { \n   const   sinks   =   {} \n   return   sinks  }", 
            "title": "Component's Structure"
        }, 
        {
            "location": "/#hello-world", 
            "text": "A simple component may return a  sinks  object containing only a  view  property, which is responsible for describing how the component should render.  const   HelloWorld   =   ( sources )   =   ({ \n   view :   ( viewArgs )   = \n     div \n       p Hello   World /p \n     /div  })   Now our component is implemented, we must use Reuse to convert it to a conventional React component:  import   ReactDOM   from   react-dom  import   reuse   from   reuse  const   main   =   ( sources )   =   ({ \n   view :   ( viewArgs )   = \n     div \n       p Hello   World /p \n     /div  })  const   HelloWorld   =   reuse ( main )  ReactDOM . render ( \n   HelloWorld   / , \n   document . getElementById ( app )  )", 
            "title": "Hello World"
        }, 
        {
            "location": "/quick-start/props-and-state/", 
            "text": "Props and State\n\n\nProps\n\n\nA stream of props is available through the sources object. The raw props are also passed to the \nview\n sink, so it can be easely used on the rendering.\n\n\nimport\n \nreuse\n \nfrom\n \nreuse\n\n\nimport\n \nReactDOM\n \nfrom\n \nreact-dom\n\n\n\ninterface\n \nProps\n \n{\n\n  \nname\n: \nstring\n\n\n}\n\n\n\nconst\n \nHello\n \n=\n \nreuse\nProps\n(\nsources\n \n=\n \n{\n\n  \nconst\n \nprops$\n \n=\n \nsources\n.\nprops\n\n\n  \nreturn\n \n{\n\n    \nview\n:\n \n({\n \nprops\n \n})\n \n=\n \n(\n\n      \ndiv\nHello\n \n{\nprops\n.\nname\n}\n/div\n\n    \n)\n\n  \n}\n\n\n})\n\n\n\nReactDOM\n.\nrender\n(\n\n  \nHello\n \nname\n=\nWorld\n \n/\n,\n\n  \ndocument\n.\ngetElementById\n(\napp\n)\n\n\n)\n\n\n\n\n\n\nComponent State\n\n\nThe state management is made through the \nstateReducer\n sink, which is a stream of reducer functions. Each reducer function must receive the latest state as argument and return a new one.\n\n\nA \ninitialState\n sink may be used to set the initial state when needed.\n\n\nThe raw state is passed to the \nview\n sink for use in the rendering.\n\n\nimport\n \nreuse\n \nfrom\n \nreuse\n\n\n\ninterface\n \nState\n \n{\n\n  \ncount\n: \nnumber\n\n\n}\n\n\n\nconst\n \nIncrementer\n \n=\n \nreuse\n{},\n \nState\n(\nsources\n \n=\n \n{\n\n  \nconst\n \nincrement\n \n=\n \nStream\n.\ncreate\nundefined\n()\n\n\n  \nreturn\n \n{\n\n    \ninitialState\n:\n \n{\n\n      \ncount\n: \n0\n,\n\n    \n},\n\n\n    \nstateReducer\n: \nincrement.mapTo\n((\nstate\n: \nState\n)\n \n=\n \n({\n\n      \ncount\n: \nstate.count\n \n+\n \n1\n,\n\n    \n})),\n\n\n    \nview\n:\n \n({\n \nstate\n,\n \nemitter\n \n})\n \n=\n \n(\n\n      \np\nCount\n:\n \n{\nstate\n.\ncount\n}\n/p\n\n      \nbutton\n \nonClick\n=\n{\nemmiter\n.\nsignal\n(\nincrement\n)}\nIncrement\n/button\n\n    \n)\n\n  \n}\n\n\n})", 
            "title": "Props and State"
        }, 
        {
            "location": "/quick-start/props-and-state/#props-and-state", 
            "text": "", 
            "title": "Props and State"
        }, 
        {
            "location": "/quick-start/props-and-state/#props", 
            "text": "A stream of props is available through the sources object. The raw props are also passed to the  view  sink, so it can be easely used on the rendering.  import   reuse   from   reuse  import   ReactDOM   from   react-dom  interface   Props   { \n   name :  string  }  const   Hello   =   reuse Props ( sources   =   { \n   const   props$   =   sources . props \n\n   return   { \n     view :   ({   props   })   =   ( \n       div Hello   { props . name } /div \n     ) \n   }  })  ReactDOM . render ( \n   Hello   name = World   / , \n   document . getElementById ( app )  )", 
            "title": "Props"
        }, 
        {
            "location": "/quick-start/props-and-state/#component-state", 
            "text": "The state management is made through the  stateReducer  sink, which is a stream of reducer functions. Each reducer function must receive the latest state as argument and return a new one.  A  initialState  sink may be used to set the initial state when needed.  The raw state is passed to the  view  sink for use in the rendering.  import   reuse   from   reuse  interface   State   { \n   count :  number  }  const   Incrementer   =   reuse {},   State ( sources   =   { \n   const   increment   =   Stream . create undefined () \n\n   return   { \n     initialState :   { \n       count :  0 , \n     }, \n\n     stateReducer :  increment.mapTo (( state :  State )   =   ({ \n       count :  state.count   +   1 , \n     })), \n\n     view :   ({   state ,   emitter   })   =   ( \n       p Count :   { state . count } /p \n       button   onClick = { emmiter . signal ( increment )} Increment /button \n     ) \n   }  })", 
            "title": "Component State"
        }, 
        {
            "location": "/quick-start/handling-events/", 
            "text": "Handling Events\n\n\nAll interaction in Reuse is managed through event streams. The events are defined inside the component function and emited inside the \nview\n sink. To easely emit events, use the \nemitter\n helper passed to \nview\n.\n\n\nconst\n \nApp\n \n=\n \nreuse\n(\nsources\n \n=\n \n{\n\n  \nconst\n \nsomeAction\n \n=\n \nStream\n.\ncreate\nSyntheticEvent\n()\n\n\n  \nreturn\n \n{\n\n    \nview\n:\n \n({\n \nemitter\n \n})\n \n=\n \n(\n\n      \nbutton\n \nonClick\n=\n{\nemmiter\n.\nemit\n(\nsomeAction\n)}\nDo\n \nsome\n \naction\n/button\n\n    \n)\n\n  \n}\n\n\n}\n\n\n\n\n\n\nThe \nemitter\n object has three methods: \nemit\n, \nsignal\n and \nemitValue\n:\n\n\n\n\nemit\n is used to create a lambda which emits to the stream de received argument;\n\n\nsignal\n is used to create a lambda which emits \nundefined\n to the stream. You may use it when the value doesn't metter;\n\n\nemitValue\n is used to create a lambda which emits a constant value to the stream.\n\n\n\n\nimport\n \nreuse\n \nfrom\n \nreuse\n\n\n\nconst\n \nApp\n \n=\n \nreuse\n(\nsources\n \n=\n \n{\n\n  \nconst\n \nfirstAction\n \n=\n \nStream\n.\ncreate\nSyntheticEvent\n()\n\n  \nconst\n \nsecondAction\n \n=\n \nStream\n.\ncreate\nundefined\n()\n\n  \nconst\n \nthirdAction\n \n=\n \nStream\n.\ncreate\nnumber\n()\n\n\n  \nreturn\n \n{\n\n    \nview\n:\n \n({\n \nemitter\n \n})\n \n=\n \n(\n\n      \nbutton\n \nonClick\n=\n{\nemmiter\n.\nemit\n(\nfirstAction\n)}\nFirst\n \naction\n/button\n\n      \nbutton\n \nonClick\n=\n{\nemmiter\n.\nsignal\n(\nsecondAction\n)}\nSecond\n \naction\n/button\n\n      \nbutton\n \nonClick\n=\n{\nemmiter\n.\nemitValue\n(\n2\n)(\nthirdAction\n)}\nThird\n \naction\n/button\n\n    \n)\n\n  \n}\n\n\n})", 
            "title": "Handling Events"
        }, 
        {
            "location": "/quick-start/handling-events/#handling-events", 
            "text": "All interaction in Reuse is managed through event streams. The events are defined inside the component function and emited inside the  view  sink. To easely emit events, use the  emitter  helper passed to  view .  const   App   =   reuse ( sources   =   { \n   const   someAction   =   Stream . create SyntheticEvent () \n\n   return   { \n     view :   ({   emitter   })   =   ( \n       button   onClick = { emmiter . emit ( someAction )} Do   some   action /button \n     ) \n   }  }   The  emitter  object has three methods:  emit ,  signal  and  emitValue :   emit  is used to create a lambda which emits to the stream de received argument;  signal  is used to create a lambda which emits  undefined  to the stream. You may use it when the value doesn't metter;  emitValue  is used to create a lambda which emits a constant value to the stream.   import   reuse   from   reuse  const   App   =   reuse ( sources   =   { \n   const   firstAction   =   Stream . create SyntheticEvent () \n   const   secondAction   =   Stream . create undefined () \n   const   thirdAction   =   Stream . create number () \n\n   return   { \n     view :   ({   emitter   })   =   ( \n       button   onClick = { emmiter . emit ( firstAction )} First   action /button \n       button   onClick = { emmiter . signal ( secondAction )} Second   action /button \n       button   onClick = { emmiter . emitValue ( 2 )( thirdAction )} Third   action /button \n     ) \n   }  })", 
            "title": "Handling Events"
        }, 
        {
            "location": "/quick-start/lifecycle/", 
            "text": "Lifecycle\n\n\nEvery React lifecycle event is emitted in the \nsources.lifecycle\n stream.\n\n\nimport\n \nreuse\n,\n \n{\n \nReactLifecycle\n \n}\n \nfrom\n \nreuse\n\n\n\ninterface\n \nState\n \n{\n\n  \nisMounted\n: \nboolean\n\n\n}\n\n\n\nconst\n \nIncrementer\n \n=\n \nreuse\n{},\n \nState\n(\nsources\n \n=\n \n({\n\n    \ninitialState\n:\n \n{\n\n      \nisMounted\n: \nfalse\n,\n\n    \n},\n\n\n    \nstateReducer\n: \nsources.lifecycle\n\n      \n.\nfilter\n(\nevent\n \n=\n \nevent\n \n===\n \nReactLifecycle\n.\ncomponentDidMount\n)\n\n      \n.\nmapTo\n((\nstate\n: \nState\n)\n \n=\n \n({\n\n        \nisMounted\n: \ntrue\n,\n\n      \n})),\n\n  \n})\n\n\n)", 
            "title": "Lifecycle"
        }, 
        {
            "location": "/quick-start/lifecycle/#lifecycle", 
            "text": "Every React lifecycle event is emitted in the  sources.lifecycle  stream.  import   reuse ,   {   ReactLifecycle   }   from   reuse  interface   State   { \n   isMounted :  boolean  }  const   Incrementer   =   reuse {},   State ( sources   =   ({ \n     initialState :   { \n       isMounted :  false , \n     }, \n\n     stateReducer :  sources.lifecycle \n       . filter ( event   =   event   ===   ReactLifecycle . componentDidMount ) \n       . mapTo (( state :  State )   =   ({ \n         isMounted :  true , \n       })), \n   })  )", 
            "title": "Lifecycle"
        }, 
        {
            "location": "/quick-start/global-state/", 
            "text": "Global State\n\n\nReuse - unlike most frontend frameworks - has it's own way of managing application's global state, which is much similar to how we manage a component's local state: the global state is updated using the \nstoreReducer\n sink, and is available to the component through the \nsources.store\n stream.\n\n\nUnlike the local state, though, we must first create the store and make it available to the whole application through the React context.\n\n\nCreating a Store\n\n\nTo create a global store, use the helper function \ncreateStore\n.\n\n\nimport\n \n{\n \ncreateStore\n \n}\n \nfrom\n \nreuse\n\n\n\ninterface\n \nStore\n \n{\n\n  \nfoo\n: \nstring\n\n\n}\n\n\n\nconst\n \ninitialStore\n \n=\n \n{\n\n  \nfoo\n:\n \nbar\n\n\n}\n\n\n\nconst\n \nglobalStore\n \n=\n \ncreateStore\nStore\n(\ninitialStore\n)\n\n\n\n\n\n\nMaking the store available\n\n\nTo make the global store available, use the High Order Component \nwithStoreProvider\n.\n\n\nimport\n \nApp\n \nfrom\n \n./app\n\n\nimport\n \nstore\n \nfrom\n \n./store\n\n\n\nconst\n \nAppWithGlobalStore\n \n=\n \nwithStoreProvider\n(\nstore\n)(\nApp\n)\n\n\n\nReactDOM\n.\nrender\n(\nAppWithGlobalStore\n \n/\n,\n \ndocument\n.\ngetElementById\n(\napp\n))", 
            "title": "Global State"
        }, 
        {
            "location": "/quick-start/global-state/#global-state", 
            "text": "Reuse - unlike most frontend frameworks - has it's own way of managing application's global state, which is much similar to how we manage a component's local state: the global state is updated using the  storeReducer  sink, and is available to the component through the  sources.store  stream.  Unlike the local state, though, we must first create the store and make it available to the whole application through the React context.", 
            "title": "Global State"
        }, 
        {
            "location": "/quick-start/global-state/#creating-a-store", 
            "text": "To create a global store, use the helper function  createStore .  import   {   createStore   }   from   reuse  interface   Store   { \n   foo :  string  }  const   initialStore   =   { \n   foo :   bar  }  const   globalStore   =   createStore Store ( initialStore )", 
            "title": "Creating a Store"
        }, 
        {
            "location": "/quick-start/global-state/#making-the-store-available", 
            "text": "To make the global store available, use the High Order Component  withStoreProvider .  import   App   from   ./app  import   store   from   ./store  const   AppWithGlobalStore   =   withStoreProvider ( store )( App )  ReactDOM . render ( AppWithGlobalStore   / ,   document . getElementById ( app ))", 
            "title": "Making the store available"
        }
    ]
}